# Python Backend Guidelines

> **ðŸ“š IMPORTANT: Code Examples Policy**  
> **ALWAYS use Context7 MCP server (https://github.com/upstash/context7) to retrieve up-to-date code snippets.**  
> This document provides principles, patterns, and architectural guidance. For actual implementation code, query Context7 or Microsoft Docs MCP server to ensure you're using the latest library versions and best practices.

## Guiding Principles

- **Type-safe Python**: Strong typing via Pydantic models and type hints. Use mypy for static type checking.
- **Always use latest stable packages**: Fetch and use the latest stable versions from PyPI unless there's a specific compatibility constraint. Update dependencies regularly.
- **Specification driven**: Define API contracts via FastAPI with Pydantic models â†’ OpenAPI spec auto-generated and served via `/docs`.

## Canonical Stack

| Layer | Technology | Notes |
| --- | --- | --- |
| **Framework** | FastAPI + Pydantic V2 + Python 3.11+ | Modern async-first framework with automatic OpenAPI generation, dependency injection, and validation. Pydantic V2 for data validation with enhanced performance. |
| **ASGI Server** | Uvicorn with Gunicorn workers | Production-ready ASGI server. Use Uvicorn for development, Gunicorn with Uvicorn workers for production. |
| **Agent Runtime** | Microsoft Agent Framework | **MUST USE Microsoft Agent Framework** - Official framework for building AI agents with Azure OpenAI/Azure AI. Supports agent creation, tool calling, streaming, and multi-agent orchestration. |
| **Realtime** | WebSocket + FastAPI WebSocket support | Native FastAPI WebSocket endpoints with async support. Consider Socket.IO for advanced features. |
| **Testing** | pytest + pytest-asyncio + httpx | Coverage â‰¥ 85%. Integration tests with TestClient. Use pytest fixtures for dependency injection in tests. |
| **Linting & Formatting** | Ruff (linter + formatter) or Black + isort + flake8 | Automated via pre-commit hooks. Ruff is recommended for speed and consolidation. |
| **Package Manager** | uv | **MUST USE uv** - An extremely fast Python package installer and resolver written in Rust. Replaces pip, pip-tools, and virtualenv. |
| **Type Checking** | mypy with strict mode | Enforce type safety. Configure in `pyproject.toml` or `mypy.ini`. |
| **CI/CD** | GitHub Actions with reusable workflows | Stages: lint â†’ type-check â†’ test â†’ build artifacts â†’ security scan â†’ deploy. |
| **Environment Secrets** | Azure Key Vault or GitHub OIDC â†’ Cloud secret store | Use python-dotenv for local development. Never commit secrets. |

## Backend Playbook (FastAPI + Azure)

### 1. FastAPI Project Layout

```
<project_root>/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                 # Application entry point, FastAPI app initialization
â”‚   â”œâ”€â”€ routers/                # API route modules
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ items.py
â”‚   â”‚   â””â”€â”€ users.py
â”‚   â”œâ”€â”€ models/                 # Pydantic models (request/response schemas)
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ item.py
â”‚   â”‚   â””â”€â”€ user.py
â”‚   â”œâ”€â”€ services/               # Business logic layer
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ item_service.py
â”‚   â”‚   â””â”€â”€ agent_service.py
â”‚   â”œâ”€â”€ repositories/           # Data access layer
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â””â”€â”€ cosmos_repository.py
â”‚   â”œâ”€â”€ core/                   # Core functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ config.py           # Settings management with Pydantic Settings
â”‚   â”‚   â”œâ”€â”€ dependencies.py     # FastAPI dependencies
â”‚   â”‚   â””â”€â”€ security.py         # Authentication/authorization
â”‚   â””â”€â”€ utils/                  # Utility functions
â”‚       â””â”€â”€ __init__.py
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ conftest.py             # Pytest fixtures
â”‚   â”œâ”€â”€ test_items.py
â”‚   â””â”€â”€ test_integration.py
â”œâ”€â”€ pyproject.toml              # Project metadata, dependencies, and tool configs
â”œâ”€â”€ uv.lock                     # Locked dependency versions (generated by uv)
â”œâ”€â”€ .env.example                # Environment variables template
â””â”€â”€ README.md
```

### 2. Type Safety & Python Best Practices

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `pydantic`, `mypy`, or `python type hints`

**Key Practices:**
- **Type hints everywhere**: Use type hints for all function signatures, variables, and class attributes
- **Pydantic models**: Use Pydantic V2 `BaseModel` for all DTOs, request/response schemas, and configuration
  - Enable `model_config = ConfigDict(frozen=True)` for immutable models
  - Use `Field()` for validation, descriptions, examples, and constraints
  - Leverage `@field_validator` and `@model_validator` for custom validation
- **Static type checking**: Run mypy in strict mode as part of CI/CD
- **Dataclasses**: Use `dataclasses` for simple data containers when Pydantic validation isn't needed
- **Enums**: Use `enum.Enum` or Pydantic's `Field(discriminator=...)` for type-safe choices

### 3. Async Excellence & Best Practices

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `asyncio`, `async python`, or `fastapi async`

**Key Practices:**
- **All I/O operations must be async**: Use `async def` and `await` for database, HTTP, file I/O
- **Never block the event loop**: Avoid blocking calls like `time.sleep()`, use `asyncio.sleep()` instead
- **Use async Azure SDK clients**: Import from `.aio` modules (e.g., `from azure.cosmos.aio import CosmosClient`)
- **Async context managers**: Always use `async with` for resource management
- **Concurrency patterns**:
  - Use `asyncio.gather()` for concurrent operations
  - Use `asyncio.Semaphore()` to limit concurrency
  - Use `asyncio.create_task()` for background tasks
- **Async iterables**: Use `async for` with `AsyncGenerator` for streaming responses
- **FastAPI background tasks**: Use `BackgroundTasks` for fire-and-forget operations

### 4. FastAPI Application Structure

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `/tiangolo/fastapi` or `fastapi lifespan middleware`

**Key Patterns:**
- **Application Initialization**: Use `@asynccontextmanager` with `lifespan` for startup/shutdown
- **Configuration**: Use Pydantic Settings with `.env` file support
- **Middleware**: Configure CORS, authentication, logging middleware
- **Router Organization**: Use `APIRouter` to organize endpoints by domain
- **Dependency Injection**: Use `Depends()` extensively for services and authentication
- **API Versioning**: Use path prefixes like `/api/v1/` for version management

### 5. Dependency Injection Pattern

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `fastapi dependency injection` or `fastapi Depends`

**Key Patterns:**
- Use `Depends()` for reusable logic injection
- Use `yield` in dependencies for setup/teardown (e.g., database connections)
- Create type aliases with `Annotated` to reduce repetition
- Dependencies can depend on other dependencies (sub-dependencies)
- Use application-level dependencies in `FastAPI(dependencies=[...])`

### 6. Database: Azure Cosmos DB for NoSQL

**Always use Cosmos DB for data persistence**. Use the native async Azure Cosmos DB SDK directly.

**Installation:**
```bash
uv add azure-cosmos azure-identity
```

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `azure-cosmos` or `/azure/azure-sdk-for-python`
- Use Microsoft Docs MCP server: Query `Azure Cosmos DB Python SDK async`

**Key Patterns:**
- **Repository Pattern**: Implement repository classes for data access abstraction
- **Async Operations**: All CRUD operations should be async
- **Client Initialization**: Use `CosmosClient` with async context managers
- **Parameterized Queries**: Use parameterized SQL queries to prevent injection
- **Partition Keys**: Design partition keys carefully for optimal performance
- **Bulk Operations**: Use controlled concurrency for batch operations
- **Error Handling**: Handle `CosmosResourceNotFoundError` and other exceptions gracefully

### 7. Realtime & WebSockets

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `fastapi websocket` or `/tiangolo/fastapi`

**Key Patterns:**
- **Connection Manager**: Implement a manager class to track active connections
- **Accept Connections**: Use `await websocket.accept()` to establish connection
- **Receive/Send Messages**: Use `await websocket.receive_text()` and `send_text()`
- **Broadcasting**: Iterate over active connections to broadcast messages
- **Disconnect Handling**: Catch `WebSocketDisconnect` exception for cleanup
- **Validation**: Use Pydantic models to validate WebSocket messages
- **Authentication**: Implement WebSocket authentication with query parameters or tokens

### 8. Agents Integration with Microsoft Agent Framework

**MUST USE Microsoft Agent Framework** for all agent-based applications.

**Installation:**
```bash
uv add agent-framework
```

**ðŸ“š Getting Code Examples:**
- **ALWAYS use Context7 MCP server** to retrieve up-to-date code snippets
- Query Context7 for: `agent-framework`, `Microsoft Agent Framework`, or `/microsoft/agent-framework`
- Use Microsoft Docs MCP server for official documentation and best practices

**Key Concepts to Explore:**
- **Basic Agent Creation**: Using `AzureOpenAIChatClient` and `AzureAIAgentClient`
- **Function Tools**: Integrating custom tools with type annotations
- **Streaming Responses**: Using `run_stream()` for real-time output
- **Azure AI Foundry Agents**: Leveraging `HostedCodeInterpreterTool`
- **Multi-Agent Orchestration**: Building workflows with `WorkflowBuilder`
- **Agent Service Pattern**: Integrating agents with FastAPI dependency injection
- **Agent as Tool**: Converting agents to tools using `.as_tool()`

**Microsoft Agent Framework Best Practices:**
- **Use Azure CLI authentication**: `AzureCliCredential()` for local development
- **Create specialized agents**: Build domain-specific agents with clear instructions
- **Leverage built-in tools**: Use `HostedCodeInterpreterTool` for code execution
- **Implement tool functions**: Define async functions with type hints for agent tools
- **Use streaming**: Stream responses for better UX with `run_stream()`
- **Multi-agent workflows**: Orchestrate multiple agents with `WorkflowBuilder`
- **Agent as tool**: Convert agents to tools using `.as_tool()` for composition
- **Environment variables**: Set `AZURE_OPENAI_ENDPOINT` and `AZURE_OPENAI_CHAT_DEPLOYMENT_NAME`
- **Context management**: Use async context managers for proper resource cleanup
- **Error handling**: Implement proper exception handling for agent operations
- **Logging**: Log all agent interactions for debugging and compliance
- **Structured outputs**: Use Pydantic models for parsing agent responses

### 9. Error Handling & Validation

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `fastapi exception handler` or `python structlog`

**Key Patterns:**
- **Custom Exceptions**: Define application-specific exception classes for domain errors
- **Exception Handlers**: Use `@app.exception_handler()` for global error handling with consistent response format
- **HTTP Exceptions**: Use `HTTPException` with appropriate status codes (404, 422, 500, etc.)
- **Automatic Validation**: Pydantic automatically validates all request/response data via `response_model`
- **Structured Logging**: Use JSON formatting for logs in production with correlation IDs
- **Error Context**: Log errors with proper context for debugging and observability
- **Consistent Responses**: Return standardized error response format across all endpoints

### 10. Testing Strategy

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `pytest-asyncio`, `httpx AsyncClient`, or `fastapi testing`

**Key Patterns:**
- **Test Structure**: Use pytest fixtures in `conftest.py` for reusable test components
- **Async Tests**: Use `@pytest.mark.asyncio` for async test functions
- **Test Client**: Use `httpx.AsyncClient` for testing FastAPI endpoints
- **Fixtures**: Define reusable fixtures for database, services, and test data
- **Dependency Overrides**: Use `app.dependency_overrides` to mock dependencies
- **Mocking**: Use `unittest.mock.AsyncMock` for async functions
- **Test Database**: Use separate test database or in-memory database
- **Coverage**: Aim for >80% code coverage with `pytest-cov`
- **Test Organization**: Organize tests by domain (test_users.py, test_items.py)
- **Integration Tests**: Mark with `@pytest.mark.integration` for separation
- **Error Cases**: Test both success and error scenarios including validation failures

### 11. Observability & Logging

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `opencensus-ext-azure` or `azure-monitor-opentelemetry`
- Use Microsoft Docs MCP server: Query `Azure Application Insights Python`

**Key Patterns:**
- **Azure Application Insights**: Use Azure Monitor OpenTelemetry for distributed tracing
- **Instrumentation**: Instrument FastAPI with `FastAPIInstrumentor`
- **Structured Logging**: Use JSON formatting with correlation IDs
- **Custom Spans**: Create spans for important operations with `tracer.start_as_current_span()`
- **Metrics**: Track custom metrics (request counts, latency, business metrics)
- **Health Endpoints**: Implement `/health` and `/health/ready` for monitoring
- **Correlation IDs**: Include request IDs in logs for end-to-end tracing
- **Performance Monitoring**: Monitor endpoint latency and throughput
- **Alerting**: Configure alerts for errors, exceptions, and performance degradation

**Observability Best Practices:**
- Use Azure Application Insights for telemetry
- Configure OpenTelemetry for distributed tracing
- Use structured logging with JSON format
- Log at appropriate levels (DEBUG, INFO, WARNING, ERROR)
- Never log sensitive data (passwords, keys, PII)
- Use correlation IDs for request tracing
- Monitor performance metrics and response times
- Set up health check endpoints

## Code Quality & Development Tools

### Pre-commit Hooks Configuration

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `pre-commit configuration` or `ruff pre-commit` for latest setup

**Key Tools:**
- **Ruff**: Fast Python linter and formatter
- **mypy**: Static type checking
- **Pre-commit hooks**: Automated checks for trailing whitespace, file endings, YAML syntax

### Ruff and Tool Configuration

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `ruff pyproject.toml` or `pytest configuration` for latest settings

**Key Configuration:**
- **Ruff**: Configure target version, line length, linting rules, and isort behavior
- **pytest**: Set up test discovery patterns, coverage options, and async mode
- **mypy**: Enable strict type checking with appropriate warnings

### Python Environment & Dependency Management with uv

**MUST USE uv** for all Python environment and package management. uv is an extremely fast Python package installer and resolver written in Rust that replaces pip, pip-tools, virtualenv, and pyenv.

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `uv` or `/astral-sh/uv` for latest usage patterns
- Official docs: https://docs.astral.sh/uv/

**Installation:**
```bash
# Windows
powershell -ExecutionPolicy ByPass -c "irm https://astral.sh/uv/install.ps1 | iex"

# macOS/Linux
curl -LsSf https://astral.sh/uv/install.sh | sh
```

**Essential Commands:**
```bash
# Project initialization
uv init my-project
uv python install 3.11
uv venv --python 3.11

# Dependency management
uv add package-name          # Add production dependency
uv add --dev package-name    # Add dev dependency
uv sync                      # Install/sync all dependencies
uv lock --upgrade            # Update lock file

# Running commands
uv run python script.py
uv run uvicorn app.main:app --reload
uv run pytest
```

**Key Practices:**
- **Commit `uv.lock`**: Ensures reproducible builds
- **Use `uv run`**: Automatically activates virtual environment
- **Replace pip**: Use `uv add` instead of `pip install`
- **Fast CI/CD**: uv significantly reduces pipeline times
- **Python versions**: Manage with `uv python install`

## Best Practices Summary

### Code Organization
- **Modular structure**: Separate routers, models, services, and repositories
- **Dependency injection**: Leverage FastAPI's DI system extensively
- **Repository pattern**: Abstract data access behind repository interfaces
- **Service layer**: Business logic in dedicated service classes

### Performance
- **Async everywhere**: Use async for all I/O operations
- **Connection pooling**: Reuse database clients and HTTP connections
- **Caching**: Implement caching for frequently accessed data
- **Background tasks**: Use `BackgroundTasks` for non-blocking operations
- **Streaming**: Use async generators for large datasets

### Security
- **Environment variables**: Use Pydantic Settings for configuration
- **Secret management**: Azure Key Vault for production secrets
- **Input validation**: Pydantic models validate all inputs automatically
- **Authentication**: Implement OAuth2 with Azure AD or similar
- **CORS**: Configure CORS middleware properly
- **Rate limiting**: Implement rate limiting for API protection

### API Design
- **RESTful patterns**: Follow REST conventions for endpoints
- **Versioning**: Use `/api/v1/` prefix for API versioning
- **Documentation**: Auto-generated OpenAPI docs at `/docs` and `/redoc`
- **Response models**: Define explicit response models for type safety
- **Status codes**: Use appropriate HTTP status codes
- **Pagination**: Implement pagination for list endpoints

### Development Workflow
- **Type checking**: Run mypy in CI/CD pipeline
- **Linting**: Use Ruff for fast, comprehensive linting
- **Testing**: Write tests for all endpoints and business logic
- **Coverage**: Maintain â‰¥85% test coverage
- **Pre-commit hooks**: Automate code quality checks
- **Documentation**: Keep README and docstrings up to date

### Azure Integration
- **Use async Azure SDKs**: Always use `.aio` modules
- **Managed Identity**: Prefer managed identity over keys in production
- **Application Insights**: Configure telemetry for monitoring
- **Retry policies**: Implement retries with exponential backoff
- **Resource cleanup**: Always use context managers for Azure clients

## Production Deployment

### ASGI Server Configuration

**Development:**
```bash
# Using uv
uv run uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

**Production:**
```bash
# Using uv with Gunicorn
uv run gunicorn app.main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
```

### Docker Configuration

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `uv docker` or `dockerfile python` for latest patterns

**Key Patterns:**
- **Base Image**: Use `python:3.11-slim` for smaller image size
- **Install uv**: Copy from `ghcr.io/astral-sh/uv:latest`
- **Multi-stage Builds**: Separate build and runtime stages
- **Dependencies First**: Copy `pyproject.toml` and `uv.lock` before app code
- **Layer Caching**: Optimize layer order for faster rebuilds
- **Run with uv**: Use `uv run` for command execution

### Azure Deployment Options

1. **Azure App Service**: Easiest deployment with built-in scaling
2. **Azure Container Apps**: Modern serverless containers with automatic scaling
3. **Azure Kubernetes Service (AKS)**: Full orchestration for complex workloads
4. **Azure Functions (Python)**: Event-driven serverless with Python 3.11 support

### Environment Variables for Production

```bash
# Azure
AZURE_COSMOS_ENDPOINT=https://your-account.documents.azure.com:443/
AZURE_COSMOS_KEY=your-cosmos-key
AZURE_OPENAI_ENDPOINT=https://your-openai.openai.azure.com/
AZURE_OPENAI_API_KEY=your-openai-key
APPLICATIONINSIGHTS_CONNECTION_STRING=your-connection-string

# Application
PROJECT_NAME="Production API"
ENVIRONMENT=production
LOG_LEVEL=INFO
ALLOWED_ORIGINS=["https://yourdomain.com"]
SECRET_KEY=your-secret-key
```

## 5. CI/CD Pipeline Example

**ðŸ“š Getting Code Examples:**
- Use Context7 MCP server: Query `github actions python` or `azure pipelines python`
- Use Microsoft Docs MCP server: Query `Azure DevOps Python pipeline`

**Key Pipeline Steps:**
1. **Checkout Code**: Use `actions/checkout@v4` or equivalent
2. **Set up Python**: Install Python 3.11+
3. **Install uv**: Download and install uv package manager
4. **Install Dependencies**: Run `uv sync` to install packages
5. **Linting**: Run `uv run ruff check .`
6. **Type Checking**: Run `uv run mypy app`
7. **Testing**: Run `uv run pytest --cov=app --cov-report=xml`
8. **Coverage Upload**: Upload coverage to Codecov or similar
9. **Build & Deploy**: Build Docker image and deploy to Azure

## Learning Resources

- **uv Documentation**: https://docs.astral.sh/uv/
- **FastAPI Documentation**: https://fastapi.tiangolo.com/
- **Pydantic Documentation**: https://docs.pydantic.dev/
- **Microsoft Agent Framework**: https://learn.microsoft.com/en-us/agent-framework/
- **Azure SDK for Python**: https://learn.microsoft.com/en-us/azure/developer/python/
- **Azure Cosmos DB Python SDK**: https://learn.microsoft.com/en-us/azure/cosmos-db/nosql/how-to-python-get-started
- **Python Type Hints**: https://docs.python.org/3/library/typing.html
- **Async Python**: https://docs.python.org/3/library/asyncio.html
